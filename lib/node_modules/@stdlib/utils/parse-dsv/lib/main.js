/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isBuffer = require( '@stdlib/assert/is-buffer' );


// VARIABLES //

var DQUOTE = '"';
var CR = '\r';
var LF = '\n';
var CRLF = '\r\n';

var TOKEN_ENUM = {
	'DELIM': 0,
	'DQUOTE': 1,
	'CR': 2,
	'LF': 3,
	'CRLF': 4,
	'TEXTDATA': 5,
	'ENDOFSTREAM': 6
};

var STATE_ENUM = {
	'INITIAL': 0,
	'RECORD': 1,
	'ESCAPED': 2,
	'NONESCAPED': 3,
	'TWODQUOTE': 4,
	'END': 5
};


// MAIN //

/**
* Returns an a function which incrementally a delimiter separated values resource.
* @param {Buffer} [DELIM] - the delimiter for the dsv
* @param {Buffer} [ENCODING] - the encoding of the buffer input
* @returns {Function} accumulator function
*
* @example
* var string2buffer = require( '@stdlib/buffer/from-string' );
* var parse_dsv = parseDsvStream();
*
* var csv = parse_dsv( string2buffer( '1,2,3' ) );
* // returns [[ "1", "2", "3" ]]
*
* csv = parse_dsv( string2buffer( '\n' ) );
* // returns [[ "1", "2", "3" ] ]
*
* csv = parse_dsv( string2buffer('4, 5') );
* // returns [[ "1", "2", "3" ], [ "4", " 5" ] ]
*
* csv = parse_dsv( string2buffer( ', 6' ) );
* // returns [ [ "1", "2", "3" ], [ "4", " 5", " 6" ] ]
*/
function parseDsvStream( DELIM = ',', ENCODING = 'utf8' ) {
	var columnSize = -1;
	var dsvState = [];
	var buffer = [];
	var column = -1;
	var state = STATE_ENUM.INITIAL;
	var row = -1;
	return incrparse;

	/**
	* When called, the function attempts to parse the input and update dsv state.
	*
	* @private
	* @param {Buffer} [chars] - a buffer of input
	* @throws {Error} if not provided a buffer or null
	* @returns {Array} an array representing the parsed dsvs
	*/
	function incrparse( chars ) {
		if ( isBuffer( chars ) ) {
			buffer = buffer.concat( chars.toString( ENCODING ).split( '' ));
		} else if ( chars === null ) {
			buffer.push( null );
		} else	{
			throw new Error( 'provide a buffer or null' );
		}
		attemptParse();
		return dsvState;
	}

	/**
	* Attempts to generate tokens from the current buffer.
	*
	* @private
	* @returns {Array} an array of tokens
	*/
	function readNextTokens() {
		var matched = true;
		var tokens = [];
		var char;
		var i;
		while ( buffer.length > 0 ) {
			char = buffer[ 0 ];
			if ( char === DELIM[ 0 ] ) {
				for ( i = 1; i < buffer.length && i < DELIM.length; i++ ) {
					if ( buffer[i] !== DELIM[i] ) { // A mismatch
						matched = false;
						break;
					}
				}
				if ( matched ) { // Everything matched
					if ( buffer.length >= DELIM.length ) { // Entire delim was matched
						buffer.splice( 0, DELIM.length ); // Remove the characters
						tokens.push({
							'type': TOKEN_ENUM.DELIM,
							'data': DELIM
						});
						continue;
					} else { // Not enough to determine if delim or not
						return tokens;
					}
				}
				// If mismatch, fall through and interpret char as normal
			}
			switch ( char ) {
			case CR:
				if ( buffer.length < 2 ) {
					return tokens; // Need at least 1 more byte to determine token
				}
				if ( buffer[1] === LF ) {
					buffer.splice( 0, 2 ); // Remove CRLF from buffer;
					tokens.push({
						'type': TOKEN_ENUM.CRLF,
						'data': CRLF
					});
				} else {
					buffer.shift();
					tokens.push({
						'type': TOKEN_ENUM.CR,
						'data': CR
					});
				}
				break;
			case LF:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.LF,
					'data': LF
				});
				break;
			case DQUOTE:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.DQUOTE,
					'data': DQUOTE
				});
				break;
			case null:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.ENDOFSTREAM,
					'data': null
				});
				return tokens;
			default:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.TEXTDATA,
					'data': char
				});
			}
		}
		return tokens;
	}

	/**
	* Attempts to update the state of the dsv based on the current buffer's contents.
	*
	* @private
	* @throws {Error} if the parser is in an invalid state or an invalid token is read
	* @returns {void}
	*/
	function attemptParse() {
		var tokens = readNextTokens();
		var token;

		/* eslint-disable no-fallthrough */
		while ( tokens.length > 0 ) {
			token = tokens.shift();
			switch ( state ) {
			case STATE_ENUM.INITIAL: // The start of a row
				dsvState.push( [] );
				row += 1;
				if ( row === 1 ) {
					// We've just recieved the first row so we can now limit the column size
					columnSize = column;
				} else if ( columnSize !== column ) {
					throw new Error( 'Unexpected size of row. Expected ' + columnSize + ' recieved ' + column );
				}
				column = -1;
			case STATE_ENUM.RECORD: // Inside a row
				column += 1;
				switch ( token.type ) {
				case TOKEN_ENUM.DQUOTE: // Starting an escaped field
					dsvState[ row ][ column ] = '';
					state = STATE_ENUM.ESCAPED;
					break;
				case TOKEN_ENUM.TEXTDATA: // Starting an nonescaped field
					dsvState[ row ][ column ] = token.data;
					state = STATE_ENUM.NONESCAPED;
					break;
				case TOKEN_ENUM.DELIM: // An empty, nonescaped field
					dsvState[ row ][ column ] = null;
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF: // An empty nonescaped field at the end of a row
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					dsvState[ row ][ column ] = null;
					state = STATE_ENUM.INITIAL;
					break;
				case TOKEN_ENUM.ENDOFSTREAM:
					state = STATE_ENUM.END;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.ESCAPED: // Inside a double quoted field
				switch ( token.type ) {
				case TOKEN_ENUM.TEXTDATA: // Some data inside an escaped field
				case TOKEN_ENUM.DELIM:
				case TOKEN_ENUM.CRLF:
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					dsvState[ row ][ column ] += token.data;
					break;
				case TOKEN_ENUM.DQUOTE: // A double quote inside an escaped field
					state = STATE_ENUM.TWODQUOTE;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.NONESCAPED: // Inside a normal field
				switch ( token.type ) {
				case TOKEN_ENUM.TEXTDATA: // Some data inside a nonescaped field
					dsvState[ row ][ column ] += token.data;
					break;
				case TOKEN_ENUM.DELIM: // A delimiter which marks the end of this field
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF: // Marks this field as the last in the row
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					state = STATE_ENUM.INITIAL;
					break;
				case TOKEN_ENUM.ENDOFSTREAM:
					state = STATE_ENUM.END;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.TWODQUOTE: // Maybe an escaped quote
				switch ( token.type ) {
				case TOKEN_ENUM.DQUOTE: // The quote was escaped
					dsvState[ row ][ column ] += DQUOTE;
					state = STATE_ENUM.ESCAPED;
					break;
				case TOKEN_ENUM.DELIM: // The quote was the end of an escaped field
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF: // The quote was the end of an escaped field which was the end of the row
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					state = STATE_ENUM.INITIAL;
					break;
				case TOKEN_ENUM.ENDOFSTREAM:
					state = STATE_ENUM.END;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.ENDOFSTREAM:
				throw new Error( 'Parser has already been closed' );
			default:
				throw new Error( 'Unknown state: ' + state );
			}
		}

		/* eslint-enable no-fallthrough */
	}
}

module.exports = parseDsvStream;
