/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var instanceOf = require( '@stdlib/assert/instance-of' );
var isBuffer = require( '@stdlib/assert/is-buffer' );
var inherit = require( '@stdlib/utils/inherit' );


// VARIABLES //

var CR = '\r';
var LF = '\n';
var CRLF = '\r\n';

var TOKEN_ENUM = {
	'DELIM': 0,
	'QUOTE': 1,
	'CR': 2,
	'LF': 3,
	'CRLF': 4,
	'TEXTDATA': 5,
	'ENDOFSTREAM': 6
};

var STATE_ENUM = {
	'INITIAL': 0,
	'RECORD': 1,
	'ESCAPED': 2,
	'NONESCAPED': 3,
	'TWOQUOTE': 4,
	'END': 5
};


// MAIN //

/* eslint-disable no-invalid-this */

/**
* Returns an a function which incrementally a delimiter separated values resource.
* @param {string} [DELIM] - the delimiter for the dsv
* @param {string} [ENCODING] - the encoding of the buffer input
* @param {string} [QUOTECHAR] - the description isnt even accurate right now
* @returns {Function} accumulator function
*
* @example
* var string2buffer = require( '@stdlib/buffer/from-string' );
* var parse_dsv = new parseDsvStream();
*
* var csv = parse_dsv.incrparse( string2buffer( '1,2,3' ) );
* // returns [[ "1", "2", "3" ]]
*
* csv = parse_dsv.incrparse( string2buffer( '\n' ) );
* // returns [[ "1", "2", "3" ] ]
*
* csv = parse_dsv.incrparse( string2buffer('4, 5') );
* // returns [[ "1", "2", "3" ], [ "4", " 5" ] ]
*
* csv = parse_dsv.incrparse( string2buffer( ', 6' ) );
* // returns [ [ "1", "2", "3" ], [ "4", " 5", " 6" ] ]
*/
function parseDsvStream( DELIM = ',', ENCODING = 'utf8', QUOTECHAR = '"' ) { // Fix class name later
	if ( !instanceOf( this, parseDsvStream ) ) {
		return new parseDsvStream( DELIM, ENCODING, QUOTECHAR );
	}
	this.QUOTECHAR = QUOTECHAR;
	this.ENCODING = ENCODING;
	this.DELIM = DELIM;
	this.columnSize = -1;
	this.rowBuffer = [];
	this.dsvState = [];
	this.buffer = [];
	this.column = -1;
	this.state = STATE_ENUM.INITIAL;
	this.row = -1;

	return this;
}

inherit( parseDsvStream, EventEmitter );

/**
* Attempts to update the state of the dsv based on the current buffer's contents.
*
* @private
* @throws {Error} if the parser is in an invalid state or an invalid token is read
* @returns {void}
*/
function attemptParse() {
	var tokens = readNextTokens.call( this );
	var token;

	/* eslint-disable no-fallthrough */
	while ( tokens.length > 0 ) {
		token = tokens.shift();
		switch ( this.state ) {
		case STATE_ENUM.INITIAL: // The start of a row
			if ( this.row > -1 ) {
				this.emit('row', this.rowBuffer, this.row);
			}
			this.rowBuffer = [];
			this.dsvState.push( [] );
			this.row += 1;
			if ( this.row === 1 ) {
				// We've just recieved the first row so we can now limit the column size
				this.columnSize = this.column;
			} else if ( this.columnSize !== this.column ) {
				throw new Error( 'Unexpected size of row. Expected ' + this.columnSize + ' recieved ' + this.column );
			}
			this.column = -1;
		case STATE_ENUM.RECORD: // Inside a row
			this.column += 1;
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // Starting an escaped field
				this.rowBuffer[ this.column ] = '';
				this.dsvState[ this.row ][ this.column ] = '';
				this.state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.TEXTDATA: // Starting an nonescaped field
				this.rowBuffer[ this.column ] = token.data;
				this.dsvState[ this.row ][ this.column ] = token.data;
				this.state = STATE_ENUM.NONESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // An empty, nonescaped field
				this.rowBuffer[ this.column ] = null;
				this.dsvState[ this.row ][ this.column ] = null;
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.CRLF: // An empty nonescaped field at the end of a row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.rowBuffer[ this.column ] = null;
				this.dsvState[ this.row ][ this.column ] = null;
				this.state = STATE_ENUM.INITIAL;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				this.state = STATE_ENUM.END;
				break;
			default:
				throw new Error( 'State: ' + this.state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + this.row + 'Column: ' + this.column );
			}
			break;
		case STATE_ENUM.ESCAPED: // Inside a double quoted field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside an escaped field
			case TOKEN_ENUM.DELIM:
			case TOKEN_ENUM.CRLF:
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.rowBuffer[ this.column ] += token.data;
				this.dsvState[ this.row ][ this.column ] += token.data;
				break;
			case TOKEN_ENUM.QUOTE: // A double quote inside an escaped field
				this.state = STATE_ENUM.TWOQUOTE;
				break;
			default:
				throw new Error( 'State: ' + this.state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + this.row + 'Column: ' + this.column );
			}
			break;
		case STATE_ENUM.NONESCAPED: // Inside a normal field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside a nonescaped field
				this.rowBuffer[ this.column ] += token.data;
				this.dsvState[ this.row ][ this.column ] += token.data;
				break;
			case TOKEN_ENUM.DELIM: // A delimiter which marks the end of this field
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.CRLF: // Marks this field as the last in the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.state = STATE_ENUM.INITIAL;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				this.state = STATE_ENUM.END;
				break;
			default:
				throw new Error( 'State: ' + this.state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + this.row + 'Column: ' + this.column );
			}
			break;
		case STATE_ENUM.TWOQUOTE: // Maybe an escaped quote
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // The quote was escaped
				this.rowBuffer[ this.column ] += this.QUOTECHAR;
				this.dsvState[ this.row ][ this.column ] += this.QUOTECHAR;
				this.state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // The quote was the end of an escaped field
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.CRLF: // The quote was the end of an escaped field which was the end of the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.state = STATE_ENUM.INITIAL;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				this.state = STATE_ENUM.END;
				break;
			default:
				throw new Error( 'State: ' + this.state + '. unexpected token. Type: ' + token.type + 'Data: ' + token.data + 'Row: ' + this.row + 'Column: ' + this.column );
			}
			break;
		case STATE_ENUM.ENDOFSTREAM:
			throw new Error( 'Parser has already been closed' );
		default:
			throw new Error( 'Unknown state: ' + this.state );
		}
	}

	/* eslint-enable no-fallthrough */
}

/**
* Attempts to generate tokens from the current buffer.
*
* @private
* @returns {Array} an array of tokens
*/
function readNextTokens() {
	var matched = true;
	var tokens = [];
	var char;
	var i;
	while ( this.buffer.length > 0 ) {
		char = this.buffer[ 0 ];
		if ( char === this.DELIM[ 0 ] ) {
			for ( i = 1;
				i < this.buffer.length && i < this.DELIM.length;
				i++ ) {
				if ( this.buffer[i] !== this.DELIM[i] ) { // A mismatch
					matched = false;
					break;
				}
			}
			if ( matched ) { // Everything matched
				if ( this.buffer.length >= this.DELIM.length ) { // Entire delim was matched
					this.buffer.splice( 0, this.DELIM.length ); // Remove the characters
					tokens.push({
						'type': TOKEN_ENUM.DELIM,
						'data': this.DELIM
					});
					continue;
				} else { // Not enough to determine if delim or not
					return tokens;
				}
			}
			// If mismatch, fall through and interpret char as normal
		}
		switch ( char ) {
		case CR:
			if ( this.buffer.length < 2 ) {
				return tokens; // Need at least 1 more byte to determine token
			}
			if ( this.buffer[1] === LF ) {
				this.buffer.splice( 0, 2 ); // Remove CRLF from buffer;
				tokens.push({
					'type': TOKEN_ENUM.CRLF,
					'data': CRLF
				});
			} else {
				this.buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.CR,
					'data': CR
				});
			}
			break;
		case LF:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.LF,
				'data': LF
			});
			break;
		case this.QUOTECHAR:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.QUOTE,
				'data': this.QUOTECHAR
			});
			break;
		case null:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.ENDOFSTREAM,
				'data': null
			});
			return tokens;
		default:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.TEXTDATA,
				'data': char
			});
		}
	}
	return tokens;
}

/**
* When called, the function attempts to parse the input and update dsv state.
*
* @name incrparse
* @memberof parseDsvStream.prototype
* @param {Buffer} [chars] - a buffer of input
* @throws {Error} if not provided a buffer or null
* @returns {Array} an array representing the parsed dsvs
*/
function incrparse( chars ) {
	if ( isBuffer( chars ) ) {
		this.buffer = this.buffer.concat( chars.toString( this.ENCODING ).split( '' ));
	} else if ( chars === null ) {
		this.buffer.push( null );
	} else	{
		throw new Error( 'provide a buffer or null' );
	}
	attemptParse.call( this );
	return this.dsvState;
}
setReadOnly( parseDsvStream.prototype, 'incrparse', incrparse);

/* eslint-enable no-invalid-this */
module.exports = parseDsvStream;
