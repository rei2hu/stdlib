/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var instanceOf = require( '@stdlib/assert/instance-of' );
var isBuffer = require( '@stdlib/assert/is-buffer' );
var inherit = require( '@stdlib/utils/inherit' );
var DelimiterGuesser = require( './delimiterguesser' );


// VARIABLES //

var CR = '\r';
var LF = '\n';
var CRLF = '\r\n';

var TOKEN_ENUM = {
	'DELIM': 0,
	'QUOTE': 1,
	'CR': 2,
	'LF': 3,
	'CRLF': 4,
	'TEXTDATA': 5,
	'ENDOFSTREAM': 6
};

var STATE_ENUM = {
	'INITIAL': 0,
	'START': 1,
	'RECORD': 2,
	'ESCAPED': 3,
	'NONESCAPED': 4,
	'TWOQUOTE': 5,
	'END': 6,
	'ERROR': 7
};


// MAIN //

/* eslint-disable no-invalid-this */

/**
* DsvParser constructor.
*
* @param {Object} [options] - constructor options
* @param {string} [options.delimiter=","] - the string that will be used for delimiting the fields in each record
* @param {Number} [options.watermark=10] - the number of rows to determine a delimiter from
* @param {string} [options.bufferEncoding="utf8"] - the encoding of buffer that will be consumed
* @param {string} [options.quoteCharacter="\""] - the character that is used for escaping fields in the data (length 1)
* @param {boolean} [options.parseHeaders=false] - whether or not the first record of the data contains header data
* @returns {DsvParser} DsvParser instance
*
* @example
* var string2buffer = require( '@stdlib/buffer/from-string' );
* var parser = new DsvParser();
* // returns <DsvParser>
*
* parser.push( string2buffer( '1,2,3' ) );
* parser.push( string2buffer( '\n' ) );
* parser.push( string2buffer('4, 5') );
* parser.push( string2buffer( ', 6' ) );
*/
function DsvParser( options = {} ) {
	if ( !instanceOf( this, DsvParser ) ) {
		return new DsvParser( options );
	}

	EventEmitter.call( this );
	this.quoteCharacter = options.quoteCharacter || '"';
	this.bufferEncoding = options.bufferEncoding || 'utf8';
	this.parseHeaders = options.parseHeaders || false;
	if ( options.delimiter ) {
		this.delimiter = options.delimiter;
	} else {
		options = {
			'watermark': options.watermark
		};
		this.__delimiterguesser = new DelimiterGuesser( options );
	}
	this.state = STATE_ENUM.START;
	this.columnSize = -1;
	this.rowBuffer = [];
	this.buffer = [];
	this.column = -1;
	this.row = -1;

	return this;
}

inherit( DsvParser, EventEmitter );

/**
* Determines if a row is valid or not and emits the row or error respectively.
*
* @private
* @returns {boolean} returns false if an error was emitted, true otherwise
*/
function emitRow() {
	if ( !this.rowBuffer.length ) { // Mainly important for the last row
		return true;
	}
	if ( this.row > 0 ) {
		if ( this.columnSize === this.column ) { // closed on the correct column
			if ( this.rowBuffer.length === this.column ) { // last field was empty nonescaped, see edge case 4 (index 3)
				this.rowBuffer.push( null );
			}
			if ( this.rowContainer ) {
				this.rowContainer.push( this.rowBuffer );
			} else {
				this.emit( 'row', this.rowBuffer, this.row );
			}
		} else {
			emitError.call( this, 'Unexpected size of row. Expected ' + this.columnSize + ' recieved ' + this.column );
			return false;
		}
	} else { // row === 0
		this.columnSize = this.column;
		if ( this.rowContainer ) {
			this.rowContainer.push( this.rowBuffer );
		} else if ( this.parseHeaders ) {
			this.emit( 'header', this.rowBuffer, this.row );
		} else {
			this.emit( 'row', this.rowBuffer, this.row );
		}
	}
	this.rowBuffer = [];
	return true;
}

/**
* Emits the end event.
*
* @private
* @returns {void}
*/
function emitEnd() {
	this.emit( 'end' ); // a buffer cant be passed null so it's impossible for this to occur immediately after delimiter guessing
	this.state = STATE_ENUM.END;
}

/**
* Emits an error.
*
* @private
* @param {string} [message] - the error message
* @returns {void}
*/
function emitError( message ) {
	if ( !this.rowContainer ) {
		this.emit( 'error', new Error( message ) );
	}
	this.state = STATE_ENUM.ERROR;
}

/**
* Attempts to update the state of the dsv based on the current buffer's contents.
*
* @private
* @returns {boolean} returns false if an error was emitted else true
*/
function attemptParse() {
	var tokens = readNextTokens.call( this );
	var token;
	var fine;

	/* eslint-disable no-fallthrough */
	while ( tokens.length > 0 ) {
		token = tokens.shift();
		switch ( this.state ) {
		case STATE_ENUM.INITIAL: // The start of a row
		case STATE_ENUM.START: // doesn't have to handle any rowBuffer or column checks
			this.row += 1;
			this.column = -1;
		case STATE_ENUM.RECORD: // Inside a row
			this.column += 1;
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // Starting an escaped field
				this.rowBuffer[ this.column ] = '';
				this.state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.TEXTDATA: // Starting an nonescaped field
				this.rowBuffer[ this.column ] = token.data;
				this.state = STATE_ENUM.NONESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // An empty, nonescaped field
				this.rowBuffer[ this.column ] = null;
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.CRLF: // An empty nonescaped field at the end of a row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.rowBuffer[ this.column ] = null;
				this.state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this.state );
				return false;
			}
			break;
		case STATE_ENUM.ESCAPED: // Inside a double quoted field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside an escaped field
			case TOKEN_ENUM.DELIM:
			case TOKEN_ENUM.CRLF:
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.rowBuffer[ this.column ] += token.data;
				break;
			case TOKEN_ENUM.QUOTE: // A double quote inside an escaped field
				this.state = STATE_ENUM.TWOQUOTE;
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this.state );
				return false;
			}
			break;
		case STATE_ENUM.NONESCAPED: // Inside a normal field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside a nonescaped field
				this.rowBuffer[ this.column ] += token.data;
				break;
			case TOKEN_ENUM.DELIM: // A delimiter which marks the end of this field
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			case TOKEN_ENUM.CRLF: // Marks this field as the last in the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this.state );
				return false;
			}
			break;
		case STATE_ENUM.TWOQUOTE: // Maybe an escaped quote
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // The quote was escaped
				this.rowBuffer[ this.column ] += this.quoteCharacter;
				this.state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // The quote was the end of an escaped field
				this.state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			case TOKEN_ENUM.CRLF: // The quote was the end of an escaped field which was the end of the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this.state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this.state );
				return false;
			}
			break;
		case STATE_ENUM.ERROR:
			emitError.call( this, 'Parser is closed due to previous error' );
			return false;
		case STATE_ENUM.END:
			emitError.call( this, 'Parser is closed by user' );
			return false;
		default:
			emitError.call( this, 'Unknown state: ' + this.state );
			return false;
		}
	}
	return true;

	/* eslint-enable no-fallthrough */
}

/**
* Attempts to generate tokens from the current buffer.
*
* @private
* @returns {Array} an array of tokens
*/
function readNextTokens() {
	var matched;
	var tokens = [];
	var char;
	var i;
	while ( this.buffer.length > 0 ) {
		matched = true;
		char = this.buffer[ 0 ];
		if ( char === this.delimiter[ 0 ] ) {
			for ( i = 1;
				i < this.buffer.length && i < this.delimiter.length;
				i++ ) {
				if ( this.buffer[ i ] !== this.delimiter[ i ] ) { // A mismatch
					matched = false;
					break;
				}
			}
			if ( matched ) { // Everything matched
				if ( this.buffer.length >= this.delimiter.length ) { // Entire delim was matched
					this.buffer.splice( 0, this.delimiter.length ); // Remove the characters
					tokens.push({
						'type': TOKEN_ENUM.DELIM,
						'data': this.delimiter
					});
					continue;
				} else { // Not enough to determine if delim or not
					return tokens;
				}
			}
			// If mismatch, fall through and interpret char as normal
		}
		switch ( char ) {
		case CR:
			if ( this.buffer.length < 2 ) {
				return tokens; // Need at least 1 more byte to determine token
			}
			if ( this.buffer[1] === LF ) {
				this.buffer.splice( 0, 2 ); // Remove CRLF from buffer;
				tokens.push({
					'type': TOKEN_ENUM.CRLF,
					'data': CRLF
				});
			} else {
				this.buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.CR,
					'data': CR
				});
			}
			break;
		case LF:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.LF,
				'data': LF
			});
			break;
		case this.quoteCharacter:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.QUOTE,
				'data': this.quoteCharacter
			});
			break;
		case null:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.ENDOFSTREAM,
				'data': null
			});
			return tokens;
		default:
			this.buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.TEXTDATA,
				'data': char
			});
		}
	}
	return tokens;
}

/**
* When called, the function attempts to parse the input and update dsv state.
*
* @name push
* @memberof DsvParser.prototype
* @param {Buffer} [chars] - a buffer of input
* @throws {Error} if not provided a buffer or null
* @returns {void}
*/
function push( chars ) {
	var delimiterGuesses;
	var success;
	var i;

	if ( isBuffer( chars ) ) {
		chars = chars.toString( this.bufferEncoding ).split( '' );
	} else if ( chars !== null ) {
		throw new Error( 'provide a buffer or null' );
	} // chars is now null or array

	if ( this.delimiter ) {
		this.buffer = this.buffer.concat( chars );
		attemptParse.call( this );
	} else {
		if ( chars === null ) {
			emitError.call( this, 'closed parser before delimiter could be determined' );
			return;
		}
		// push to delimiterguesser
		delimiterGuesses = this.__delimiterguesser.push( chars );
		if ( delimiterGuesses ) { // here are some guesses
			for ( i = 0; i < delimiterGuesses.length; i++ ) {
				this.delimiter = delimiterGuesses[ i ];
				this.buffer = this.__delimiterguesser.buffer.slice( 0 ); // make a copy

				this.rowContainer = [];

				success = attemptParse.call( this );
				if ( success ) {
					this.emit( 'delimiter', this.delimiter, this.rowContainer );
					this.rowContainer = null; // unset to allow emiting/avoid pushing rows to this
					return;
				}
			}

			// don't need to unset rowContainer here because the parser will be in an error state and unusable anyways
			emitError.call( this, 'couldnt determine delimiter, tried: ' + delimiterGuesses.join(' ') );
		}
	}
}
setReadOnly( DsvParser.prototype, 'push', push);

/* eslint-enable no-invalid-this */
module.exports = DsvParser;
