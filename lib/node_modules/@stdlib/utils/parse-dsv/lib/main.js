/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isBuffer = require( '@stdlib/assert/is-buffer' );


// VARIABLES //

var DQUOTE = '"';
var CR = '\r';
var LF = '\n';
var CRLF = '\r\n';

var TOKEN_ENUM = {
	'DELIM': 0,
	'DQUOTE': 1,
	'CR': 2,
	'LF': 3,
	'CRLF': 4,
	'TEXTDATA': 5
};

var STATE_ENUM = {
	'INITIAL': 0,
	'RECORD': 1,
	'ESCAPED': 2,
	'NONESCAPED': 3,
	'TWODQUOTE': 4
};


// MAIN //

/**
* Returns an a function which incrementally a delimiter separated values resource.
* @param {Buffer} [DELIM] - the delimiter for the dsv
* @param {Buffer} [ENCODING] - the encoding of the buffer input
* @returns {Function} accumulator function
*
* @example
* var string2buffer = require( '@stdlib/buffer/from-string' );
* var parse_dsv = parseDsvStream();
*
* var csv = parse_dsv( string2buffer( '1,2,3' ) );
* // returns [[ "1", "2", "3" ]]
*
* csv = parse_dsv( string2buffer( '\n' ) );
* // returns [[ "1", "2", "3" ] ]
*
* csv = parse_dsv( string2buffer('4, 5') );
* // returns [[ "1", "2", "3" ], [ "4", " 5" ] ]
*
* csv = parse_dsv( string2buffer( ', 6' ) );
* // returns [ [ "1", "2", "3" ], [ "4", " 5", " 6" ] ]
*/
function parseDsvStream( DELIM = ',', ENCODING = 'utf8' ) {
	var dsvState = [];
	var buffer = [];
	var column = -1;
	var state = STATE_ENUM.INITIAL;
	var row = -1;
	return incrparse;

	/**
	* When called, the function attempts to parse the input and update dsv state.
	*
	* @private
	* @param {Buffer} [chars] - a buffer of input
	* @throws {Error} if not provided a buffer or null
	* @returns {Array} an array representing the parsed dsvs
	*/
	function incrparse( chars ) {
		if ( isBuffer( chars ) ) {
			buffer = buffer.concat( chars.toString( ENCODING ).split( '' ));
		} else if ( chars === null ) {
			buffer.push( null );
		} else	{
			throw new Error( 'provide a buffer or null' );
		}
		attemptParse();
		return dsvState;
	}

	/**
	* Attempts to generate tokens from the current buffer.
	*
	* @private
	* @returns {Array} an array of tokens
	*/
	function readNextTokens() {
		var matched = true;
		var tokens = [];
		var char;
		var i;
		while ( buffer.length > 0 ) {
			char = buffer[ 0 ];
			if ( char === DELIM[ 0 ] ) {
				for ( i = 1; i < buffer.length && i < DELIM.length; i++ ) {
					if ( buffer[i] !== DELIM[i] ) { // A mismatch
						matched = false;
						break;
					}
				}
				if ( matched ) { // Everything matched
					if ( buffer.length >= DELIM.length ) { // Entire delim was matched
						buffer.splice( 0, DELIM.length ); // Remove the characters
						tokens.push({
							'type': TOKEN_ENUM.DELIM,
							'data': DELIM
						});
						continue;
					} else { // Not enough to determine if delim or not
						return tokens;
					}
				}
				// If mismatch, fall through and interpret char as normal
			}
			switch ( char ) {
			case CR:
				if ( buffer.length < 2 ) {
					return tokens; // Need at least 1 more byte to determine token
				}
				if ( buffer[1] === LF ) {
					buffer.splice( 0, 2 ); // Remove CRLF from buffer;
					tokens.push({
						'type': TOKEN_ENUM.CRLF,
						'data': CRLF
					});
				} else {
					buffer.shift();
					tokens.push({
						'type': TOKEN_ENUM.CR,
						'data': CR
					});
				}
				break;
			case LF:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.LF,
					'data': LF
				});
				break;
			case DQUOTE:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.DQUOTE,
					'data': DQUOTE
				});
				break;
			case null:
				buffer.shift();
				return tokens;
			default:
				buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.TEXTDATA,
					'data': char
				});
			}
		}
		return tokens;
	}

	/**
	* Attempts to update the state of the dsv based on the current buffer's contents.
	*
	* @private
	* @throws {Error} if the parser is in an invalid state or an invalid token is read
	* @returns {void}
	*/
	function attemptParse() {
		var tokens = readNextTokens();
		var token;

		/* eslint-disable no-fallthrough */
		while ( tokens.length > 0 ) {
			token = tokens.shift();
			switch ( state ) {
			case STATE_ENUM.INITIAL: // initial state
				dsvState.push( [] );
				row += 1;
				column = -1;
			case STATE_ENUM.RECORD: // start of a row
				column += 1;
				switch ( token.type ) {
				case TOKEN_ENUM.DQUOTE:
					dsvState[ row ][ column ] = '';
					state = STATE_ENUM.ESCAPED;
					break;
				case TOKEN_ENUM.TEXTDATA:
					dsvState[ row ][ column ] = token.data;
					state = STATE_ENUM.NONESCAPED;
					break;
				case TOKEN_ENUM.DELIM:
					dsvState[ row ][ column ] = '';
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF:
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					dsvState[ row ][ column ] = '';
					state = STATE_ENUM.INITIAL;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.ESCAPED:
				switch ( token.type ) {
				case TOKEN_ENUM.TEXTDATA:
				case TOKEN_ENUM.DELIM:
				case TOKEN_ENUM.CRLF:
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					if ( dsvState[ row ][ column ] ) {
						dsvState[ row ][ column ] += token.data;
					} else {
						dsvState[ row ][ column ] = token.data;
					}
					break;
				case TOKEN_ENUM.DQUOTE:
					state = STATE_ENUM.TWODQUOTE;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.NONESCAPED:
				switch ( token.type ) {
				case TOKEN_ENUM.TEXTDATA:
					dsvState[ row ][ column ] += token.data;
					break;
				case TOKEN_ENUM.DELIM:
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF:
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					state = STATE_ENUM.INITIAL;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			case STATE_ENUM.TWODQUOTE:
				switch ( token.type ) {
				case TOKEN_ENUM.DQUOTE:
					dsvState[ row ][ column ] += DQUOTE;
					state = STATE_ENUM.ESCAPED;
					break;
				case TOKEN_ENUM.DELIM:
					state = STATE_ENUM.RECORD;
					break;
				case TOKEN_ENUM.CRLF:
				case TOKEN_ENUM.CR:
				case TOKEN_ENUM.LF:
					state = STATE_ENUM.INITIAL;
					break;
				default:
					throw new Error( 'State: ' + state + '. unexpected token ' + token.type + 'Data: ' + token.data + 'Row: ' + row + 'Column: ' + column );
				}
				break;
			default:
				throw new Error( 'Unknown state: ' + state );
			}
		}

		/* eslint-enable no-fallthrough */
	}
}

module.exports = parseDsvStream;
