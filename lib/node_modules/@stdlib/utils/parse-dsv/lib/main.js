/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var defineProperty = require( '@stdlib/utils/define-property' );
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var instanceOf = require( '@stdlib/assert/instance-of' );
var isObject = require( '@stdlib/assert/is-plain-object' );
var isBuffer = require( '@stdlib/assert/is-buffer' );
var getKeys = require( '@stdlib/utils/keys' );
var inherit = require( '@stdlib/utils/inherit' );
var copy = require( '@stdlib/utils/copy' );
var merge = require( '@stdlib/utils/merge' );
var defaults = require( './defaults.json' );


// VARIABLES //

var PRIVATE_PROPS = [
	'_state',
	'_columnSize',
	'_rowBuffer',
	'_buffer',
	'_rowContainer'
];

var CR = '\r';
var LF = '\n';
var CRLF = '\r\n';

var TOKEN_ENUM = {
	'DELIM': 0,
	'QUOTE': 1,
	'CR': 2,
	'LF': 3,
	'CRLF': 4,
	'TEXTDATA': 5,
	'ENDOFSTREAM': 6
};

var STATE_ENUM = {
	'INITIAL': 0,
	'START': 1,
	'RECORD': 2,
	'ESCAPED': 3,
	'NONESCAPED': 4,
	'TWOQUOTE': 5,
	'END': 6,
	'ERROR': 7
};


// MAIN //

/* eslint-disable no-invalid-this */

/**
* DsvParser constructor.
*
* @param {Object} [options] - constructor options
* @param {string} [options.delimiter=","] - the string that will be used for delimiting the fields in each record
* @param {Number} [options.watermark=10] - the number of rows to determine a delimiter from
* @param {Number} [options.threshhold] - the threshold for delimiter guessing
* @param {string} [options.bufferEncoding="utf8"] - the encoding of buffer that will be consumed
* @param {string} [options.quoteCharacter="\""] - the character that is used for escaping fields in the data (length 1)
* @param {boolean} [options.parseHeaders=false] - whether or not the first record of the data contains header data
* @throws {TypeError} if the options object is not an object
* @returns {DsvParser} DsvParser instance
*
* @example
* var string2buffer = require( '@stdlib/buffer/from-string' );
* var parser = new DsvParser();
* // returns <DsvParser>
*
* parser.push( string2buffer( '1,2,3' ) );
* parser.push( string2buffer( '\n' ) );
* parser.push( string2buffer('4, 5') );
* parser.push( string2buffer( ', 6' ) );
*/
function DsvParser( options = {} ) {
	var opts;
	var keys;
	var key;
	var i;

	if ( !instanceOf( this, DsvParser ) ) {
		return new DsvParser( options );
	}

	opts = copy( defaults );

	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid argument. `options` argument must be an object. Value: `' + options + '`.' );
		}
		opts = merge( opts, options );
	}

	EventEmitter.call( this );

	for ( i = 0; i < PRIVATE_PROPS.length; i++ ) {
		defineProperty( this, PRIVATE_PROPS[ i ], {
			'configurable': false,
			'enumerable': false,
			'writable': true,
			'value': null
		});
	}

	keys = getKeys( opts );
	for ( i = 0; i < keys.length; i++ ) {
		key = keys[ i ];
		this[ key ] = opts[ key ];
	}

	if ( this.delimiter === null ) {
		// (/\r\n|\r|\n)(?=(?:[^"]*"[^"]*")*[^"]*$)/g;
		this.__newlineRegex = new RegExp( '(\r\n|\r|\n)(?=(?:[^' +
			this.quoteCharacter + ']*' + this.quoteCharacter +
			'[^' + this.quoteCharacter + ']*' + this.quoteCharacter +
			')*[^' + this.quoteCharacter + ']*$)', 'g');
	}

	initializeStateVariables.call( this );

	return this;
}

inherit( DsvParser, EventEmitter );

/**
 * Initializes variables that handle the state of the parser.
 *
 * @private
 * @returns {void}
 */
function initializeStateVariables() {
	this._state = STATE_ENUM.START;
	this._columnSize = -1;
	this._rowBuffer = [];
	this._buffer = [];

	this.column = -1;
	this.row = -1;
}

/**
* Determines if a row is valid or not and emits the row or error respectively.
*
* @private
* @returns {boolean} returns false if an error was emitted, true otherwise
*/
function emitRow() {
	if ( !this._rowBuffer.length ) { // Mainly important for the last row
		return true;
	}
	if ( this.row > 0 ) {
		if ( this._columnSize === this.column ) { // closed on the correct column
			if ( this._rowBuffer.length === this.column ) { // last field was empty nonescaped, see edge case 4 (index 3)
				this._rowBuffer.push( null );
			}
			if ( this._rowContainer ) {
				this._rowContainer.push( this._rowBuffer );
			} else {
				this.emit( 'row', this._rowBuffer, this.row );
			}
		} else {
			emitError.call( this, 'Unexpected size of row. Expected ' + this._columnSize + ' recieved ' + this.column + ' for row ' + this.row );
			return false;
		}
	} else { // row === 0
		this._columnSize = this.column;
		if ( this._rowContainer ) {
			this._rowContainer.push( this._rowBuffer );
		} else if ( this.parseHeaders ) {
			this.emit( 'header', this._rowBuffer, this.row );
		} else {
			this.emit( 'row', this._rowBuffer, this.row );
		}
	}
	this._rowBuffer = [];
	return true;
}

/**
* Emits the end event.
*
* @private
* @returns {void}
*/
function emitEnd() {
	this.emit( 'end' ); // a buffer cant be passed null so it's impossible for this to occur immediately after delimiter guessing
	this._state = STATE_ENUM.END;
}

/**
* Emits an error.
*
* @private
* @param {string} [message] - the error message
* @returns {void}
*/
function emitError( message ) {
	if ( !this._rowContainer ) {
		this.emit( 'error', new Error( message ) );
	}
	this._state = STATE_ENUM.ERROR;
}

/**
* Attempts to update the state of the dsv based on the current buffer's contents.
*
* @private
* @returns {boolean} returns false if an error was emitted else true
*/
function attemptParse() {
	var tokens = readNextTokens.call( this );
	var token;
	var fine;

	/* eslint-disable no-fallthrough */
	while ( tokens.length > 0 ) {
		token = tokens.shift();
		switch ( this._state ) {
		case STATE_ENUM.INITIAL: // The start of a row
		case STATE_ENUM.START: // doesn't have to handle any rowBuffer or column checks
			this.row += 1;
			this.column = -1;
		case STATE_ENUM.RECORD: // Inside a row
			this.column += 1;
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // Starting an escaped field
				this._rowBuffer[ this.column ] = '';
				this._state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.TEXTDATA: // Starting an nonescaped field
				this._rowBuffer[ this.column ] = token.data;
				this._state = STATE_ENUM.NONESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // An empty, nonescaped field
				this._rowBuffer[ this.column ] = null;
				this._state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.CRLF: // An empty nonescaped field at the end of a row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this._rowBuffer[ this.column ] = null;
				this._state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this._state );
				return false;
			}
			break;
		case STATE_ENUM.ESCAPED: // Inside a double quoted field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside an escaped field
			case TOKEN_ENUM.DELIM:
			case TOKEN_ENUM.CRLF:
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this._rowBuffer[ this.column ] += token.data;
				break;
			case TOKEN_ENUM.QUOTE: // A double quote inside an escaped field
				this._state = STATE_ENUM.TWOQUOTE;
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this._state );
				return false;
			}
			break;
		case STATE_ENUM.NONESCAPED: // Inside a normal field
			switch ( token.type ) {
			case TOKEN_ENUM.TEXTDATA: // Some data inside a nonescaped field
				this._rowBuffer[ this.column ] += token.data;
				break;
			case TOKEN_ENUM.DELIM: // A delimiter which marks the end of this field
				this._state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			case TOKEN_ENUM.CRLF: // Marks this field as the last in the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this._state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this._state );
				return false;
			}
			break;
		case STATE_ENUM.TWOQUOTE: // Maybe an escaped quote
			switch ( token.type ) {
			case TOKEN_ENUM.QUOTE: // The quote was escaped
				this._rowBuffer[ this.column ] += this.quoteCharacter;
				this._state = STATE_ENUM.ESCAPED;
				break;
			case TOKEN_ENUM.DELIM: // The quote was the end of an escaped field
				this._state = STATE_ENUM.RECORD;
				break;
			case TOKEN_ENUM.ENDOFSTREAM:
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				emitEnd.call( this );
				break;
			case TOKEN_ENUM.CRLF: // The quote was the end of an escaped field which was the end of the row
			case TOKEN_ENUM.CR:
			case TOKEN_ENUM.LF:
				this._state = STATE_ENUM.INITIAL;
				fine = emitRow.call( this );
				if ( !fine ) {
					return false;
				}
				break;
			default:
				emitError.call( this, 'Unexpected token. Type:' + token.type + ' Data:' + token.data + ' Row:' + this.row + ' Column:' + this.column + ' State:' + this._state );
				return false;
			}
			break;
		case STATE_ENUM.ERROR:
			emitError.call( this, 'Parser is closed due to previous error' );
			return false;
		case STATE_ENUM.END:
			emitError.call( this, 'Parser is closed by user' );
			return false;
		default:
			emitError.call( this, 'Unknown state: ' + this._state );
			return false;
		}
	}
	return true;

	/* eslint-enable no-fallthrough */
}

/**
* Attempts to generate tokens from the current buffer.
*
* @private
* @returns {Array} an array of tokens
*/
function readNextTokens() {
	var matched;
	var tokens = [];
	var char;
	var i;
	while ( this._buffer.length > 0 ) {
		matched = true;
		char = this._buffer[ 0 ];
		if ( char === this.delimiter[ 0 ] ) {
			for ( i = 1;
				i < this._buffer.length && i < this.delimiter.length;
				i++ ) {
				if ( this._buffer[ i ] !== this.delimiter[ i ] ) { // A mismatch
					matched = false;
					break;
				}
			}
			if ( matched ) { // Everything matched
				if ( this._buffer.length >= this.delimiter.length ) { // Entire delim was matched
					this._buffer.splice( 0, this.delimiter.length ); // Remove the characters
					tokens.push({
						'type': TOKEN_ENUM.DELIM,
						'data': this.delimiter
					});
					continue;
				} else { // Not enough to determine if delim or not
					return tokens;
				}
			}
			// If mismatch, fall through and interpret char as normal
		}
		switch ( char ) {
		case CR:
			if ( this._buffer.length < 2 ) {
				return tokens; // Need at least 1 more byte to determine token
			}
			if ( this._buffer[1] === LF ) {
				this._buffer.splice( 0, 2 ); // Remove CRLF from buffer;
				tokens.push({
					'type': TOKEN_ENUM.CRLF,
					'data': CRLF
				});
			} else {
				this._buffer.shift();
				tokens.push({
					'type': TOKEN_ENUM.CR,
					'data': CR
				});
			}
			break;
		case LF:
			this._buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.LF,
				'data': LF
			});
			break;
		case this.quoteCharacter:
			this._buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.QUOTE,
				'data': this.quoteCharacter
			});
			break;
		case null:
			this._buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.ENDOFSTREAM,
				'data': null
			});
			return tokens;
		default:
			this._buffer.shift();
			tokens.push({
				'type': TOKEN_ENUM.TEXTDATA,
				'data': char
			});
		}
	}
	return tokens;
}

/**
* Guesses the delimiter for input.
* @private
* @returns {void|Array} - the guessed delimiters if the buffer has been filled
*/
function guessDelimiter() {
	var quoteMatcher;
	var accumulator;
	var metaCount;
	var matches;
	var guesses;
	var counts;
	var lines;
	var input;
	var count;
	var rows;
	var keys;
	var char;
	var row;
	var i;
	var j;
	var k;

	input = this._buffer.join( '' );
	lines = input.match( this.__newlineRegex );
	if ( lines ) {
		lines = lines.length;
	}

	if ( !lines || lines < this.watermark ) {
		return;
	}

	rows = input.split( this.__newlineRegex );

	for ( j = 0; j < rows.length; j++ ) {
		row = rows[ j ];
		counts = {};
		for ( i = 0; i < row.length; i++ ) { // count up occurences of each char in each row
			char = row[ i ];
			if ( !counts[ char ] && char !== this.quotechar ) {
				matches = row.match( new RegExp( char + '(?=(?:[^"]*"[^"]*")*[^"]*$)', 'g' ) );
				if ( matches ) {
					counts[ char ] = matches.length;
				} else {
					counts[ char ] = 0;
				}
			}
		}
		rows[ j ] = counts; // this is ok to do because it won't be used again in the loops
	}

	if ( Object.keys( rows[ rows.length - 1 ] ).length < 1 ) {
		lines -= 1;
	}

	accumulator = {};
	for ( k = 0; k < rows.length; k++ ) {
		keys = Object.keys( rows[ k ] );
		for ( i = 0; i < keys.length; i++ ) {
			char = keys[ i ];
			count = rows[ k ][ char ];
			metaCount = 0;
			for ( j = 0; j < rows.length; j++ ) {
				if ( rows[ j ][ char ] === count ) {
					metaCount += 1;
				}
			}
			if ( !accumulator[ char ] ||
				accumulator[ char ].maxMeta < metaCount ) {
				accumulator[ char ] = {
					'maxMeta': metaCount, // the most common amount of times char occured count times in a row
					'count': count // the number of times char occurred in those rows
				};
			}
		}
	}

	/**
	* Sorts entries based on their meta counts.
	*
	* @private
	* @param {Array} [a] - the first entry
	* @param {Array} [b] - the second entry
	* @returns {Number} difference
	*/
	function comparator( a, b ) {
		var difference = b[ 1 ].maxMeta - a[ 1 ].maxMeta;
		if ( difference !== 0 ) {
			return difference;
		}

		// prefer symbols over alphanumeric
		char = a[ 0 ].charCodeAt( 0 );
		if ( ( char >= 48 && char <= 57 ) || // numbers
			( char >= 65 && char <= 90 ) || // uppercase
			( char >= 97 && char <= 122 ) ) { // lowercase
			return 1;
		}
		char = b[ 0 ].charCodeAt( 0 );
		if ( ( char >= 48 && char <= 57 ) || // numbers
			( char >= 65 && char <= 90 ) || // uppercase
			( char >= 97 && char <= 122 ) ) { // lowercase
			return -1;
		}
		return b[ 1 ].count - a[ 1 ].count; // if both symbols, pick one that occurs more per row
	}

	accumulator = Object.entries( accumulator )
		.sort( comparator );

	guesses = [];

	// simpler delimiter guessing method: find quotes surrounded by the same character e.g. ,"asd",
	quoteMatcher = new RegExp( '(.)' + this.quoteCharacter + '.*?' + this.quoteCharacter + '\\1' );
	matches = input.match( quoteMatcher );

	if ( matches ) {
		guesses.push( matches[ 1 ] );
	}

	for ( i = 0; i < accumulator.length; i++ ) {
		if ( accumulator[ i ][ 1 ].maxMeta / lines >= this.threshold &&
			accumulator[ i ][ 0 ] !== guesses[ 0 ] ) {
			guesses.push(accumulator[ i ][ 0 ]); // add the delimiter to guesses
		} else {
			break;
		}
	}

	return guesses;
}

/**
* When called, the function attempts to parse the input and update dsv state.
*
* @name push
* @memberof DsvParser.prototype
* @param {Buffer} [chars] - a buffer of input
* @throws {Error} if not provided a buffer or null
* @returns {void}
*/
function push( chars ) {
	var delimiterGuesses;
	var success;
	var copy;
	var i;

	if ( isBuffer( chars ) ) {
		chars = chars.toString( this._bufferEncoding ).split( '' );
	} else if ( chars !== null ) {
		throw new Error( 'provide a buffer or null' );
	} // chars is now null or array

	this._buffer = this._buffer.concat( chars );
	if ( this.delimiter ) { // if there is a delimiter
		attemptParse.call( this );
	} else {
		if ( chars === null ) {
			emitError.call( this, 'closed parser before delimiter could be determined' );
			return;
		}
		delimiterGuesses = guessDelimiter.call( this );
		if ( delimiterGuesses ) { // here are some guesses
			copy = this._buffer.slice( 0 ); // make a backup copy of the buffer

			for ( i = 0; i < delimiterGuesses.length; i++ ) {
				this.delimiter = delimiterGuesses[ i ];
				this._rowContainer = [];

				initializeStateVariables.call( this );

				this._buffer = copy.slice( 0 );

				success = attemptParse.call( this );

				if ( success ) {
					this.emit( 'delimiter', this.delimiter, this._rowContainer, delimiterGuesses);
					this._rowContainer = null; // unset to allow emiting/avoid pushing rows to this
					return;
				}
			}

			this._rowContainer = null; // actually need to unset to emit error
			emitError.call( this, 'couldnt determine delimiter, tried: ' + delimiterGuesses.join(' ') );
		}
	}
}
setReadOnly( DsvParser.prototype, 'push', push);

/* eslint-enable no-invalid-this */
module.exports = DsvParser;
