const fs = require('fs');
const Buffer = require('buffer').Buffer;

/* The ABNF grammar [2] appears as follows:

   file = [header CRLF] record *(CRLF record) [CRLF]
   header = name *(COMMA name)
   record = field *(COMMA field)
   name = field
   field = (escaped / non-escaped)
   escaped = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE
   non-escaped = *TEXTDATA
   COMMA = %x2C
   CR = %x0D ;as per section 6.1 of RFC 2234 [2]
   DQUOTE =  %x22 ;as per section 6.1 of RFC 2234 [2]
   LF = %x0A ;as per section 6.1 of RFC 2234 [2]
   CRLF = CR LF ;as per section 6.1 of RFC 2234 [2]
   TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E

*/

// fs.createReadStream(path, options);

let DELIM;
const DQUOTE = 0x22;
const CR = 0x0D;
const LF = 0x0A;
const CRLF = (CR << 8) | LF;
// TEXTDATA = 0x20 - 0x21 / 0x23 - 0x2B / 0x2D - 0x7E


const tokens = {
    'DELIM': 0,
    'DQUOTE': 1,
    'CR': 2,
    'LF': 3,
    'CRLF': 4,
    'TEXTDATA': 5
}

/*
    The "header" parameter indicates the presence or absence of the
    header line.  Valid values are "present" or "absent".
    Implementors choosing not to use this parameter must make their
    own decisions as to whether the header line is present or absent.
*/

// assume no headers for now
function parse_dsv_file(path, delimiter = ',') {
    // assume delimiter is always 1 byte long
    DELIM = delimiter.charCodeAt(0);

    const fd = fs.openSync(path, 'r');
    const buf = Buffer.alloc(1);
    const sz = fs.statSync(path).size;

    /* file reading related business */
    let position = 0;
    function read(bytes) {
        if (position === sz) return false; // eof
        // fs.readSync(fd, buffer, offset, length, position);
        fs.readSync(fd, buf, 0, bytes, position);
        position += bytes;
        return true;
    }
    function peek(bytes) {
        if (position === sz) return false; // eof
        fs.readSync(fd, buf, 0, bytes, position);
        return true;
    }
    function peekNextToken() {
        const oldPos = position;
        const token = readNextToken();
        position = oldPos;
        return token;
    }
    function readNextToken() {
        // DELIM, CR, DQUOTE, LF, CRLF, TEXTDATA
        // tokens are in the form:
        // { type: number, data: whatever }
        if (!read(1)) return false; // eof

        switch (buf[0]) {
            case DELIM:
                return { type: tokens.DELIM, data: delimiter };
            case CR:
                if (peek(1) && buf[0] == LF) {
                    read(1);
                    return { type: tokens.CRLF, data: '\n' };
                }
                return { type: tokens.CR, data: CR }; // will this pop up?
            case LF:
                return { type: tokens.LF, data: LF }; // will this pop up?
            case DQUOTE:
                return { type: tokens.DQUOTE, data: '"' };
            default:
                // textdata or bust
                if (!((buf[0] >= 0x20 && buf[0] <= 0x21) ||
                    (buf[0] >= 0x23 || buf[0] <= 0x2B) ||
                    (buf[0] >= 0x2D || buf[0] <= 0x7E)))
                    throw new Error('expected TEXTDATA, recieved ... at position' + position);

                let textdata = buf.toString('utf8');
                while (peek(1)) {
                    // TEXTDATA = 0x20 - 0x21 / 0x23 - 0x2B / 0x2D - 0x7E
                    if ((buf[0] >= 0x20 && buf[0] <= 0x21) ||
                        (buf[0] >= 0x23 && buf[0] <= 0x2B) ||
                        (buf[0] >= 0x2D && buf[0] <= 0x7E)) {
                        textdata += buf.toString('utf8');
                        read(1);
                    } else {
                        return { type: tokens.TEXTDATA, data: textdata };
                    }
                }
                return { type: tokens.TEXTDATA, data: textdata };
        }
    }



    function readFile() {
        /*
            file = [header CRLF] record *(CRLF record) [CRLF]
            assumption is currently no header
        */
        const container = [];
        container.push(readRecord());
        let tok = peekNextToken();
        // while (tok.type === tokens.CRLF) {
        while (tok.type === tokens.LF) { // js seems to use \n which is LF instead of CRLF
            readNextToken(); // discard LF
            if (!peekNextToken()) break; // guard against ending \n, horrible way to do it probably
            container.push(readRecord());
            tok = peekNextToken();
        }
        return container;
    }
    function readRecord() {
        /*
            record = field *(COMMA field)
        */
        const row = [];
        row.push(readField());
        let tok = peekNextToken();
        while (tok.type === tokens.DELIM) {
            readNextToken(); // discard delim
            row.push(readField());
            tok = peekNextToken();
        }
        return row;
    }
    function readField() {
        /*
            field = (escaped / non-escaped)
            escaped = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE
            non-escaped = *TEXTDATA
        */
        const tok = readNextToken();
        switch (tok.type) {
            case tokens.DQUOTE: // escaped
                return handleEscaped();
            case tokens.TEXTDATA: // non-escaped
                return tok.data;
        }

    }
    function handleEscaped() {
        /*
            escaped = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE
        */
        let escaped = '';
        let tok = readNextToken();
        while (true) {
            switch (tok.type) {
                case tokens.TEXTDATA:
                case tokens.DELIM:
                case tokens.CR:
                case tokens.LF:
                    escaped += tok.data;
                    break;
                case tokens.DQUOTE:
                    const tok2 = peekNextToken();
                    if (tok2.type !== tokens.DQUOTE) return escaped;
                    // else 2dquote, an escaped double quote
                    readNextToken();
                    escaped += '""';
                    break;
                default:
                    throw new Error('unexpected token at position ' + position);
            }
            tok = readNextToken();
        }
    }

    return readFile();
}

module.exports = parse_dsv_file;
