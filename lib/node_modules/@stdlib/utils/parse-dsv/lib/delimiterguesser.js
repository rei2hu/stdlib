/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

var minimumRows = 10;
var buffer = '';
var estimatedRowCount = 1;
var newlineRegex = /\r\n|\r|\n/g;

// note that is possible for the newline character
// to appear inside quoted fields which means it won't
// be perfect

// input will be an array via push method for parser
function delimiterGuesser(input) {
	var estimatedInputRowCount;
	var inputString;
	var difference;
	var metaCount;
	var counts;
	var count;
	var rows;
	var char;
	var keys;
	var i;

	inputString = input.join('');
	estimatedInputRowCount = (inputString.match(newlineRegex) || []).length;

	buffer = ''; // temporary will have one instance per parser

	estimatedRowCount += estimatedInputRowCount;
	buffer += inputString;
	if ( estimatedRowCount < minimumRows ) {
		return;
	}

	// 10 rows detected
	rows = buffer.split(newlineRegex);
	rows = rows.map( function mapper( row ) {
		counts = {};
		for ( i = 0; i < row.length; i++ ) { // count up occurences of each char in each row
			char = row[ i ];
			if ( !counts[ char ] ) {
				counts[ char ] = 1;
			} else {
				counts[ char ] += 1;
			}
		}
		return counts;
	}); // returns an array of objects containing char:count pairs
	rows = rows.reduce( function reducer( accumulator, rowData ) {
		keys = Object.keys( rowData );
		for ( i = 0; i < keys.length; i++ ) {
			char = keys[ i ];
			count = rowData[ char ];
			metaCount = rows.filter( function filter( element ) {
				return element[ char ] === count;
			}).length;
			if ( !accumulator[ char ] || accumulator[ char ].maxMeta < metaCount) {
				accumulator[ char ] = {
					maxMeta: metaCount, // the most common amount of times char occured count times in a row
					count: count // the number of times char occurred in those rows
				};
			}
		}
		return accumulator;
	}, {}); // returns an object with char:object pairs, inner object explained above
	rows = Object.entries( rows ).sort( function comparator( a, b ) {
		difference = b[1].maxMeta - a[1].maxMeta;
		if (difference !== 0) {
			return difference;
		}
		return b[1].count - a[1].count; // if equal pick the one that has higher occurrence
	});

	// rows is an ordering guess
	return rows[0][0]; // return the guessed delimiter;
}

module.exports = delimiterGuesser;
