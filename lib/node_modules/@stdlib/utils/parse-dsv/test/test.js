/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var string2buffer = require( '@stdlib/buffer/from-string' );
var DSVParser = require( './../lib' );
var fixtures = require( './js/fixtures/fixtures.json' );

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof DSVParser, 'function', 'main export is a function' );
	t.end();
});

tape( 'the implementation properly parses csv data', function test( t ) {
	var delimiter;
	var quotechar;
	var expected;
	var headers;
	var options;
	var objRow;
	var parsed;
	var input;
	var data;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === fixtures.length ) {
			t.end();
			return;
		}

		expected = fixtures[ counter ].expected;
		data = fixtures[ counter ].data;
		delimiter = data.delimiter;
		quotechar = data.quotechar;
		headers = data.headers;
		input = data.input;
		options = {
			'DELIM': delimiter,
			'HEADERS': headers,
			'QUOTECHAR': quotechar
		};
		pd = new DSVParser( options );

		parsed = [];
		headers = null;
		pd.on( 'header', function listener( headerRow, rowCount) {
			headers = headerRow;
			t.equal( rowCount, 0, 'the header row is the first row' );
		});
		pd.on( 'row', function listener( row ) {
			if ( headers ) {
				objRow = row.reduce( function reducer( acc, ele, idx ) { // eslint-disable-line max-nested-callbacks
					acc[ headers[ idx ] ] = ele;
					return acc;
				}, {});
				parsed.push( objRow );
			} else {
				parsed.push( row );
			}
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});

		pd.incrparse( string2buffer( input ) );
		pd.incrparse( null );
	})( 0 );
});

tape( 'the implementation properly throws errors on improperly formatted csv data', function test( t ) {
	var badDsv = [
		'aa,aaa\na,a,a,a\na,a,a', // weird number of entries per row
		'"aa"aa",aaaa,aaaaaaaaa', // non escaped quote
		'aa,aa,"aa",aaa"aaaaaaa', // quote in non escaped string
		'aa,aa,"aaaaaaaaaaaaaaa' // end of stream before completing
	];
	var pd;

	(function recursiveHelper( counter ) {
		if (counter === badDsv.length ) {
			t.end();
			return;
		}
		pd = new DSVParser();
		pd.once('error', function errorHandler( error ) {
			t.ok( true, 'threw an error ' + error );
			recursiveHelper( counter + 1 );
		});

		pd.incrparse( string2buffer( badDsv[ counter ] ) );
		if ( counter === 3 ) {
			pd.incrparse( null );
		}
	})( 0 );
});
