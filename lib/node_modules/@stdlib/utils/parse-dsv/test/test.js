/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var string2buffer = require( '@stdlib/buffer/from-string' );
var replace = require( '@stdlib/string/replace' );
var randu = require( '@stdlib/random/base/randu' );
var floor = require( '@stdlib/math/base/special/floor' );
var DSVParser = require( './../lib' );


// FIXTURES //

var fixtures = require( './js/fixtures/fixtures.json' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof DSVParser, 'function', 'main export is a function' );
	t.end();
});

tape( 'the implementation properly parses csv data', function test( t ) {
	var delimiter;
	var quotechar;
	var expected;
	var headers;
	var options;
	var objRow;
	var parsed;
	var input;
	var data;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === fixtures.length ) {
			t.end();
			return;
		}

		expected = fixtures[ counter ].expected;
		data = fixtures[ counter ].data;
		delimiter = data.delimiter;
		quotechar = data.quotechar;
		headers = data.headers;
		input = data.input;
		options = {
			'delimiter': delimiter,
			'parseHeaders': headers,
			'quoteCharacter': quotechar
		};
		pd = new DSVParser( options );

		parsed = [];
		headers = null;
		pd.on( 'header', function listener( headerRow, rowCount ) {
			headers = headerRow;
			t.equal( rowCount, 0, 'the header row is the first row' );
		});
		pd.on( 'row', function listener( row ) {
			if ( headers ) {
				objRow = row.reduce( function reducer( acc, ele, idx ) { // eslint-disable-line max-nested-callbacks
					acc[ headers[ idx ] ] = ele;
					return acc;
				}, {});
				parsed.push( objRow );
			} else {
				parsed.push( row );
			}
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'hit an error ' + error + ' while parsing ' + input);
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation handles edge cases properly', function test( t ) {
	var edgeCases = [
		[ '', [] ], // Empty data
		[ '\n', [ [ null ] ] ], // Empty data with extra newline or one row with one empty unescaped field
		[ '\n\n', [ [ null ], [ null ] ] ], // Same as above but with another newline
		[ ',\n,\n,', [ [ null, null ], [ null, null ], [ null, null ] ] ], // Output ended early or last record has 2 empty escaped fields
		[ ',\n,\n,\n', [ [ null, null ], [ null, null ], [ null, null ] ] ], // Same as above but with another newline
		[ '"",""\n,\n"",\n,""\n', [ [ '', '' ], [ null, null ], [ '', null ], [ null, '' ] ] ] // Combination of above
	];
	var expected;
	var parsed;
	var input;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === edgeCases.length ) {
			t.end();
			return;
		}
		expected = edgeCases[ counter ][ 1 ];
		input = edgeCases[ counter ][ 0 ];
		pd = new DSVParser({
			'delimiter': ','
		});

		parsed = [];
		pd.on( 'row', function listener( row ) {
			parsed.push(row);
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'threw an error ' + error );
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation emits errors on improperly formatted csv data', function test( t ) {
	var badDsv = [
		'aa,aaa\na,a,a,a\na,a,a', // Weird number of entries per row
		'"aa"aa",aaaa,aaaaaaaaa', // Non-escaped quote
		'aa,aa,"aa",aaa"aaaaaaa', // Quote in non escaped string
		'aa,aa,"aaaaaaaaaaaaaaa' // End of stream before completing
	];
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === badDsv.length ) {
			t.end();
			return;
		}
		pd = new DSVParser({
			'delimiter': ','
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( true, 'emitted an error ' + error );
			recursiveHelper( counter + 1 );
		});

		pd.push( string2buffer( badDsv[ counter ] ) );
		if ( counter === 3 ) {
			pd.push( null );
		}
	})( 0 );
});

tape( 'the implementation can accurately guess the delimiter for csv data', function test( t ) {
	var iterations = 1000;
	var delimiter;
	var failures = 0;
	var input;
	var data;
	var pd;

	function generateDsvString( rows, columns ) {
		var delimiter;
		var data = '';
		var rand;
		var i;
		var j;

		delimiter = floor( randu() * 4 ).toString(); // Pick 0, 1, 2, or 3 as a delimiter

		for ( i = 0; i < rows; i++ ) {
			data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' ); // Generate a string of 0s, 1s, 2s, and 3s, and replaces the delimiter with r
			for ( j = 1; j < columns; j++ ) {
				data += delimiter;
				rand = randu();
				if ( rand < 0.5 ) {
					data += '"';
					if ( rand < 0.15 ) {
						data += floor( randu() * 99 ).toString( 4 ); // Generates a string with delimiters
					} else if ( rand < 0.3 ) {
						data += floor( randu() * 99 ).toString( 4 ).replace( delimiter, '\n' ); // Generate a string with newlines
					} else if ( rand < 0.45 ) {
						data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, '""' ); // Generate a string with escaped quotes
					} else {
						data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' ); // Generate a normal string without newlines or delimiters
					}
					data += '"';
				} else {
					data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' );
				}
			}
			data += '\n';
		}

		return {
			'input': data,
			'delimiter': delimiter
		};
	}

	(function recursiveHelper( counter ) {
		if ( counter === iterations ) {
			t.ok( failures / iterations < 0.1, 'guessed enough delimiter cases correctly' );
			t.end();
			return;
		}

		data = generateDsvString( 25, 5 );
		input = data.input;
		delimiter = data.delimiter;

		pd = new DSVParser({
			'watermark': 10,
			'quotechar': '"'
		});

		pd.on( 'delimiter', function listener( delimiterGuess, rows, delimiterGuesses) {
			if ( delimiter !== delimiterGuess &&
				!delimiterGuesses.includes( delimiter ) ) {
				failures += 1;
			}
			recursiveHelper( counter + 1 );
		});

		pd.on( 'error', function errorHandler() {
			failures += 1;
			recursiveHelper( counter + 1 );
		});

		pd.push( string2buffer( input ) );
	})( 0 );
});
