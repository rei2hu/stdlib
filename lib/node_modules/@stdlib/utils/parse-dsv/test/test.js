/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var string2buffer = require( '@stdlib/buffer/from-string' );
var replace = require( '@stdlib/string/replace' );
var randu = require( '@stdlib/random/base/randu' );
var floor = require( '@stdlib/math/base/special/floor' );
var DSVParser = require( './../lib' );


// FIXTURES //

var fixtures = require( './js/fixtures/fixtures.json' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof DSVParser, 'function', 'main export is a function' );
	t.end();
});

tape( 'the implementation properly parses csv data', function test( t ) {
	var delimiter;
	var quotechar;
	var expected;
	var headers;
	var options;
	var objRow;
	var parsed;
	var input;
	var data;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === fixtures.length ) {
			t.end();
			return;
		}

		expected = fixtures[ counter ].expected;
		data = fixtures[ counter ].data;
		delimiter = data.delimiter;
		quotechar = data.quotechar;
		headers = data.headers;
		input = data.input;
		options = {
			'delimiter': delimiter,
			'parseHeaders': headers,
			'quoteCharacter': quotechar
		};
		pd = new DSVParser( options );

		parsed = [];
		headers = null;
		pd.on( 'header', function listener( headerRow, rowCount ) {
			headers = headerRow;
			t.equal( rowCount, 0, 'the header row is the first row' );
		});
		pd.on( 'row', function listener( row ) {
			if ( headers ) {
				objRow = row.reduce( function reducer( acc, ele, idx ) { // eslint-disable-line max-nested-callbacks
					acc[ headers[ idx ] ] = ele;
					return acc;
				}, {});
				parsed.push( objRow );
			} else {
				parsed.push( row );
			}
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'hit an error ' + error + ' while parsing ' + input);
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation handles edge cases properly', function test( t ) {
	var edgeCases = [
		[ '', [] ], // empty data
		[ '\n', [ [ null ] ] ], // empty data with extra newline or one row with one empty unescaped field
		[ '\n\n', [ [ null ], [ null ] ] ], // same as above but with another newline
		[ ',\n,\n,', [ [ null, null ], [ null, null ], [ null, null ] ] ], // output ended early or last record has 2 empty escaped fields
		[ ',\n,\n,\n', [ [ null, null ], [ null, null ], [ null, null ] ] ], // same as above but with another newline
		[ '"",""\n,\n"",\n,""\n', [ [ '', '' ], [ null, null ], [ '', null ], [ null, '' ] ] ] // combination of above
	];
	var expected;
	var parsed;
	var input;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === edgeCases.length ) {
			t.end();
			return;
		}
		expected = edgeCases[ counter ][ 1 ];
		input = edgeCases[ counter ][ 0 ];
		pd = new DSVParser({
			'delimiter': ','
		});

		parsed = [];
		pd.on( 'row', function listener( row ) {
			parsed.push(row);
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'threw an error ' + error );
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation emits errors on improperly formatted csv data', function test( t ) {
	var badDsv = [
		'aa,aaa\na,a,a,a\na,a,a', // weird number of entries per row
		'"aa"aa",aaaa,aaaaaaaaa', // non escaped quote
		'aa,aa,"aa",aaa"aaaaaaa', // quote in non escaped string
		'aa,aa,"aaaaaaaaaaaaaaa' // end of stream before completing
	];
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === badDsv.length ) {
			t.end();
			return;
		}
		pd = new DSVParser({
			'delimiter': ','
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( true, 'emitted an error ' + error );
			recursiveHelper( counter + 1 );
		});

		pd.push( string2buffer( badDsv[ counter ] ) );
		if ( counter === 3 ) {
			pd.push( null );
		}
	})( 0 );
});

tape( 'temporary delimiter guessing tests', function test( t ) {
	var sampleDsv = [
		[ 'a,a\nb,b\nc,c\nd,d\ne,e\nf,f\ng,g\nh,h\ni,i\nj,j\nk,k', ',' ],
		[ 'a,a\na,b\na,c\na,d\na,e\na,f\na,g\na,h\na,i\na,j\nk,k', ',' ],
		[ 'a,|,a\na,|,b\na,|,c\na,|,d\na,|,e\na,|,f\na,|,g\na,|,h\na|,,i\na,|,j\nk,|,k', ',' ],
		[ 'name-age\nfewi-16\nr3hfqeo-13\nfeon-1\njdioj-9\njidas-1\ndjais-8\nhasd-8\nnasdk-0', '-' ],
		[ 'a,s,d,f\na,s,d,f\r\na,s,d,f\r\na,s,d,f\r\na,s,d,f\r\na,s,d,f\r\na,s,d,f\r\na,s,d,f\r\n', ',' ]
	];
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === sampleDsv.length ) {
			t.end();
			return;
		}
		pd = new DSVParser({
			'watermark': 8
		});
		pd.on( 'delimiter', function listener( delimiter, rows, otherGuesses ) {
			if ( delimiter === sampleDsv[ counter ][ 1 ] ) {
				t.equals( delimiter, sampleDsv[ counter ][ 1 ], 'was able to guess the delimiter for ' + sampleDsv[ counter ][ 0 ] + ' guessed: ' + delimiter );
			} else {
				t.ok( otherGuesses.includes( sampleDsv[ counter ][ 1 ] ), 'found a different valid delimiter but also considered the correct delimiter' );
			}
		});
		pd.on( 'end', function listener() {
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'threw an error ' + error );
		});

		pd.push( string2buffer( sampleDsv[ counter ][ 0 ] ) );
		pd.push( null );
	})( 0 );
});

tape( 'temporary delimiter guessing tests2', function test( t ) {
	var iterations = 1000;
	var delimiter;
	var failures = 0;
	var input;
	var data;
	var pd;

	function generateDsvString( rows, columns ) {
		var delimiter;
		var data = '';
		var rand;
		var i;
		var j;

		delimiter = floor( randu() * 4 ).toString(); // 0, 1, 2, or 3

		for ( i = 0; i < rows; i++ ) {
			data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' ); // generate a string of 0/1/2/3s
			for ( j = 1; j < columns; j++ ) {
				data += delimiter;
				rand = randu();
				if ( rand < 0.5 ) {
					data += '"';
					if ( rand < 0.25 ) {
						data += floor( randu() * 99 ).toString( 4 ); // not as much potential
					} else if ( rand < 0.45 ) {
						data += floor( randu() * 99 ).toString( 4 ).replace( delimiter, '\n' ); // potential to mess up a lot
					} else {
						data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' ); // safe data
					}
					data += '"';
				} else {
					data += replace( floor( randu() * 99 ).toString( 4 ), delimiter, 'r' );
				}
			}
			data += '\n';
		}

		return {
			'input': data,
			'delimiter': delimiter
		};
	}

	(function recursiveHelper( counter ) {
		if ( counter === iterations ) {
			t.ok( failures / iterations < 0.2, 'guessed enough delimiter cases correctly. failure score: ' + failures + '/' + iterations);
			t.end();
			return;
		}

		data = generateDsvString( 25, 5 );
		input = data.input;
		delimiter = data.delimiter;

		pd = new DSVParser({
			'watermark': 10,
			'quotechar': '"'
		});

		pd.on( 'delimiter', function listener( delimiterGuess, rows, delimiterGuesses) {
			if ( delimiter !== delimiterGuess ) {
				if ( delimiterGuesses.includes( delimiter ) ) {
					failures += 0.00001;
				} else {
					failures += 1;
				}
			}
			recursiveHelper( counter + 1 );
		});

		pd.on( 'error', function errorHandler() {
			failures += 1;
			recursiveHelper( counter + 1 );
		});

		pd.push( string2buffer( input ) );
	})( 0 );
});
