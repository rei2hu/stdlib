/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var string2buffer = require( '@stdlib/buffer/from-string' );
var DSVParser = require( './../lib' );
var fixtures = require( './js/fixtures/fixtures.json' );

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof DSVParser, 'function', 'main export is a function' );
	t.end();
});

tape( 'the implementation properly parses csv data', function test( t ) {
	var delimiter;
	var quotechar;
	var expected;
	var headers;
	var options;
	var objRow;
	var parsed;
	var input;
	var data;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === fixtures.length ) {
			t.end();
			return;
		}

		expected = fixtures[ counter ].expected;
		data = fixtures[ counter ].data;
		delimiter = data.delimiter;
		quotechar = data.quotechar;
		headers = data.headers;
		input = data.input;
		options = {
			'delimiter': delimiter,
			'parseHeaders': headers,
			'quoteCharacter': quotechar
		};
		pd = new DSVParser( options );

		parsed = [];
		headers = null;
		pd.on( 'header', function listener( headerRow, rowCount ) {
			headers = headerRow;
			t.equal( rowCount, 0, 'the header row is the first row' );
		});
		pd.on( 'row', function listener( row ) {
			if ( headers ) {
				objRow = row.reduce( function reducer( acc, ele, idx ) { // eslint-disable-line max-nested-callbacks
					acc[ headers[ idx ] ] = ele;
					return acc;
				}, {});
				parsed.push( objRow );
			} else {
				parsed.push( row );
			}
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'hit an error ' + error + ' while parsing ' + input);
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation handles edge cases properly', function test( t ) {
	var edgeCases = [
		[ '', [] ], // empty data
		[ '\n', [ [ null ] ] ], // empty data with extra newline or one row with one empty unescaped field
		[ '\n\n', [ [ null ], [ null ] ] ], // same as above but with another newline
		[ ',\n,\n,', [ [ null, null ], [ null, null ], [ null, null ] ] ], // output ended early or last record has 2 empty escaped fields
		[ ',\n,\n,\n', [ [ null, null ], [ null, null ], [ null, null ] ] ], // same as above but with another newline
		[ '"",""\n,\n"",\n,""\n', [ [ '', '' ], [ null, null ], [ '', null ], [ null, '' ] ] ] // combination of above
	];
	var expected;
	var parsed;
	var input;
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === edgeCases.length ) {
			t.end();
			return;
		}
		expected = edgeCases[ counter ][ 1 ];
		input = edgeCases[ counter ][ 0 ];
		pd = new DSVParser();

		parsed = [];
		pd.on( 'row', function listener( row ) {
			parsed.push(row);
		});
		pd.on( 'end', function callback() {
			t.deepEqual( parsed, expected, 'parses ' + input + ' properly.' );
			recursiveHelper( counter + 1 );
		});
		pd.on( 'error', function errorHandler( error ) {
			t.ok( false, 'threw an error ' + error );
		});

		pd.push( string2buffer( input ) );
		pd.push( null );
	})( 0 );
});

tape( 'the implementation emits errors on improperly formatted csv data', function test( t ) {
	var badDsv = [
		'aa,aaa\na,a,a,a\na,a,a', // weird number of entries per row
		'"aa"aa",aaaa,aaaaaaaaa', // non escaped quote
		'aa,aa,"aa",aaa"aaaaaaa', // quote in non escaped string
		'aa,aa,"aaaaaaaaaaaaaaa' // end of stream before completing
	];
	var pd;

	(function recursiveHelper( counter ) {
		if ( counter === badDsv.length ) {
			t.end();
			return;
		}
		pd = new DSVParser();
		pd.on( 'error', function errorHandler( error ) {
			t.ok( true, 'threw an error ' + error );
			recursiveHelper( counter + 1 );
		});

		pd.push( string2buffer( badDsv[ counter ] ) );
		if ( counter === 3 ) {
			pd.push( null );
		}
	})( 0 );
});

tape( 'temporary delimiter guessing tests', function test( t ) {
	var sampleDsv = [
		[ 'a,a\nb,b\nc,c\nd,d\ne,e\nf,f\ng,g\nh,h\ni,i\nj,j\nk,k', ',' ],
		[ 'a,a\na,b\na,c\na,d\na,e\na,f\na,g\na,h\na,i\na,j\nk,k', ',' ],
		[ 'a,|,a\na,|,b\na,|,c\na,|,d\na,|,e\na,|,f\na,|,g\na,|,h\na|,,i\na,|,j\nk,|,k', ',' ],
		[ 'name-age\nfewi-16\nr3hfqeo-13\nfeon-1\njdioj-9\njidas-1\ndjais-8\nhasd-8\nnasdk-0', '-' ]
		// [ '"",""\n"",""\n"",""\n"",""\n"",""\n"",""\n"",""\n"",""\n"",""\n"",""', ',' ] // example of failing test because " appears more times and is consitent
	];
	var guesser = require('@stdlib/utils/parse-dsv/lib/delimiterguesser');
	var guess;
	var i;

	for ( i = 0; i < sampleDsv.length; i++ ) {
		guess = guesser(sampleDsv[i][0].split(''));
		t.equal(guess, sampleDsv[i][1], 'guesses the delimiter correctly');
	}
	t.end();
});
